name: Content Guard

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
    paths: ['docs/**', 'scripts/**', '.github/**']

permissions:
  contents: write
  pull-requests: write
  issues: write
  checks: write

jobs:
  guard:
    name: Run Content Checks
    runs-on: ubuntu-latest
    if: github.event.pull_request.draft == false

    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Setup Node
        uses: actions/setup-node@v6
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Band A compliance
        id: guard
        run: |
          set -o pipefail
          echo "Running Band A compliance checks..."
          GUARD_FORMAT=json node scripts/guard.mjs | tee guard-output.json
          GUARD_EXIT=${PIPESTATUS[0]}
          node <<'NODE'
          const fs = require('node:fs')
          const data = JSON.parse(fs.readFileSync('guard-output.json', 'utf8'))
          console.log(`Guard status: ${data.status.toUpperCase()}`)
          if (data.red.length) {
            console.log('\nüî¥ RED FINDINGS')
            for (const issue of data.red) console.log(`- ${issue}`)
          }
          if (data.yellow.length) {
            console.log('\nüü° YELLOW WARNINGS')
            for (const issue of data.yellow) console.log(`- ${issue}`)
          }
          NODE
          STATUS=$(jq -r '.status' guard-output.json)
          echo "status=$STATUS" >> $GITHUB_OUTPUT
          exit $GUARD_EXIT
        continue-on-error: true

      - name: Drift audit
        id: drift
        run: |
          set -o pipefail
          DRIFT_FORMAT=json pnpm run drift | tee drift-output.json
          DRIFT_STATUS=$(jq -r '.status' drift-output.json)
          DRIFT_WARNINGS=$(jq '.warnings | length' drift-output.json)
          echo "status=$DRIFT_STATUS" >> $GITHUB_OUTPUT
          echo "warnings=$DRIFT_WARNINGS" >> $GITHUB_OUTPUT
        continue-on-error: true

      - name: UX scan
        id: uxscan
        run: pnpm run ux:scan
        continue-on-error: true

      - name: Link validation
        id: links
        run: |
          echo "Running link validation..."
          pnpm run links > links-output.txt 2>&1
          LINK_EXIT=$?
          cat links-output.txt
          echo "links_exit_code=$LINK_EXIT" >> $GITHUB_OUTPUT
          exit $LINK_EXIT
        continue-on-error: true

      - name: Secret scan
        id: gitleaks
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true

      - name: Build documentation
        id: build
        env:
          SKIP_DOCS_GUARD: '1'
        run: pnpm run docs:build
        continue-on-error: true

      - name: Determine status
        id: status
        run: |
          GUARD_EXIT=${{ steps.guard.outcome }}
          LINKS_EXIT=${{ steps.links.outcome }}
          UX_EXIT=${{ steps.uxscan.outcome }}
          GITLEAKS_EXIT=${{ steps.gitleaks.outcome }}
          BUILD_EXIT=${{ steps.build.outcome }}
          GUARD_STATUS='${{ steps.guard.outputs.status }}'

          if [[ "$GUARD_EXIT" == "failure" ]] || [[ "$GITLEAKS_EXIT" == "failure" ]] || [[ "$BUILD_EXIT" == "failure" ]]; then
            echo "status=red" >> $GITHUB_OUTPUT
            echo "label=red" >> $GITHUB_OUTPUT
          elif [[ "$LINKS_EXIT" == "failure" ]] || [[ "$UX_EXIT" == "failure" ]] || [[ "$GUARD_STATUS" == "yellow" ]]; then
            echo "status=yellow" >> $GITHUB_OUTPUT
            echo "label=yellow" >> $GITHUB_OUTPUT
          else
            echo "status=green" >> $GITHUB_OUTPUT
            echo "label=green" >> $GITHUB_OUTPUT
          fi

      - name: Comment on PR
        uses: actions/github-script@v8
        if: always()
        with:
          script: |
            const status = '${{ steps.status.outputs.status }}';
            const guardResult = '${{ steps.guard.outcome }}';
            const guardStatus = '${{ steps.guard.outputs.status }}';
            const linksResult = '${{ steps.links.outcome }}';
            const uxResult = '${{ steps.uxscan.outcome }}';
            const driftStatus = '${{ steps.drift.outputs.status }}';
            const driftWarnings = '${{ steps.drift.outputs.warnings }}';
            const gitleaksResult = '${{ steps.gitleaks.outcome }}';
            const buildResult = '${{ steps.build.outcome }}';

            const emoji = {
              'green': '‚úÖ',
              'yellow': '‚ö†Ô∏è',
              'red': '‚ùå'
            }[status] || '‚ùì';

            const statusText = {
              'green': 'APPROVED',
              'yellow': 'REVIEW REQUIRED',
              'red': 'BLOCKED'
            }[status] || 'UNKNOWN';

            const message = `## ${emoji} Governance Compliance Report

            **Overall Status: ${statusText}**

            | Governance Check | Result |
            |------------------|--------|
            | Band A Compliance | ${
              guardResult === 'success'
                ? (guardStatus === 'yellow' ? '‚ö†Ô∏è Passed w/ warnings' : '‚úÖ Passed')
                : '‚ùå Failed'
            } |
            | Link Integrity | ${linksResult === 'success' ? '‚úÖ Passed' : '‚ö†Ô∏è Issues Found'} |
            | Drift Audit | ${
              driftStatus === 'warning'
                ? `‚ö†Ô∏è ${driftWarnings || 0} warning(s)`
                : '‚úÖ Clear'
            } |
            | UX Scan | ${uxResult === 'success' ? '‚úÖ Passed' : '‚ö†Ô∏è Issues Found'} |
            | Sensitive Data Scan | ${gitleaksResult === 'success' ? '‚úÖ Passed' : '‚ùå Secrets Detected'} |
            | Documentation Build | ${buildResult === 'success' ? '‚úÖ Passed' : '‚ùå Build Failed'} |

            ${status === 'green' ? 'üéâ **All governance checks passed.** This PR complies with Band A content policy and is ready for auto-merge (pending manual checklist completion).' : ''}
            ${status === 'yellow' ? '‚ö†Ô∏è **Manual review required.** This PR has warnings that need human judgment before merging. Check the automated PR checklist comment for details.' : ''}
            ${status === 'red' ? 'üõë **Merge blocked.** This PR violates governance policies. Please address all red failures before requesting review.' : ''}

            ---

            **What these checks mean:**
            - **Band A Compliance:** Verifies content follows public-safe sanitization rules (no internal URLs, ticket IDs, calendar dates, secrets, personal data)
            - **Link Integrity:** Validates all internal documentation links work correctly
            - **Drift Audit:** Highlights storytelling metadata and inclusive-language gaps (non-blocking hygiene)
            - **UX Scan:** Ensures primary action callouts are present before the first section for pages that declare one
            - **Sensitive Data Scan:** Ensures no API keys, tokens, or credentials are exposed
            - **Documentation Build:** Confirms the site builds successfully with your changes

            See [Governance Policy](https://lop-louis.github.io/go-to-docs/governance) for Band A guidelines.`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: message
            });

      - name: Label PR
        uses: actions/github-script@v8
        if: always()
        with:
          script: |
            const label = '${{ steps.status.outputs.label }}';

            // Validate label is not empty
            if (!label || label.trim() === '') {
              console.log('Warning: Label is empty, skipping label operation');
              return;
            }

            const labels = ['green', 'yellow', 'red'];
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = context.issue.number;
            const prAuthor = context.payload.pull_request?.user?.login ?? '';
            const labelColors = {
              green: '0f766e',
              yellow: 'f59e0b',
              red: 'dc2626'
            };

            // Remove other status labels (ignore if missing)
            for (const l of labels) {
              if (l === label) continue;
              try {
                await github.rest.issues.removeLabel({
                  owner,
                  repo,
                  issue_number,
                  name: l
                });
              } catch (err) {
                if (err?.status !== 404) {
                  console.log(`Skipping removal of label "${l}" due to: ${err.message}`);
                }
              }
            }

            // Ensure target label exists (create if needed)
            async function ensureLabelExists(name) {
              try {
                await github.rest.issues.getLabel({ owner, repo, name });
                return true;
              } catch (err) {
                if (err?.status === 404) {
                  const color = labelColors[name] ?? '6b7280';
                  try {
                    await github.rest.issues.createLabel({
                      owner,
                      repo,
                      name,
                      color,
                      description: `Content guard status: ${name}`
                    });
                    return true;
                  } catch (createErr) {
                    console.log(`Failed to create label "${name}": ${createErr.message}`);
                    return false;
                  }
                }
                console.log(`Failed to look up label "${name}": ${err.message}`);
                return false;
              }
            }

            const ensured = await ensureLabelExists(label);
            if (!ensured) {
              console.log(`Skipping addLabels because label "${label}" could not be ensured.`);
              return;
            }

            // Add current status label (log failures without throwing)
            try {
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number,
                labels: [label]
              });
            } catch (err) {
              if (err?.status === 403) {
                console.log(`Failed to add label "${label}" (likely due to permissions). Skipping.`);
              } else {
                console.log(`Failed to add label "${label}": ${err.message}`);
              }
            }

      - name: Confirm all checks passed
        if: steps.status.outputs.status == 'green'
        id: combined
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SHA: ${{ github.event.pull_request.head.sha }}
        run: |
          state=$(gh api repos/${{ github.repository }}/commits/$SHA/status --jq '.state')
          echo "state=$state" >> $GITHUB_OUTPUT
          if [ "$state" != "success" ]; then
            echo "Combined commit status is $state. Auto-merge will not be enabled."
          fi

      - name: Enable auto-merge for green PRs
        if: steps.status.outputs.status == 'green' && steps.combined.outputs.state == 'success'
        uses: peter-evans/enable-pull-request-automerge@v3
        with:
          pull-request-number: ${{ github.event.pull_request.number }}
          token: ${{ secrets.GITHUB_TOKEN }}
          merge-method: squash

      - name: Fail if red
        if: steps.status.outputs.status == 'red'
        run: |
          echo "‚ùå Content guard failed with red status"
          exit 1
